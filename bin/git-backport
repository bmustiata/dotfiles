#!/usr/bin/env python

import subprocess
import re
import sys

issue_id = None
from_version = None
to_version = None

if len(sys.argv) > 3:
    issue_id = sys.argv[1]
    from_version = sys.argv[2]
    to_version = sys.argv[3]
else:
    issue_id = sys.argv[1]
    from_version = "develop"  # FIXME master?
    to_version = sys.argv[2]


def print_usage():
    print("""
    You need to call it like this:

    git backport [-sp|--single-patch] [-ib|--ignore-branch] ISSUE-ID [FROM_VERSION] TO_VERSION

    This will take care of everything that's needed for the backport.
    If the FROM_VERSION is missing, it assumes there is a branch
     targeted for merging in develop/master.
""")

BACKPORT_BRANCH_CHECK = re.compile(r'^.*?/\d+\.\d+(\.\d+)?/.*$')
BRANCH_NAME_PARSER = re.compile(r'(remotes/origin/)?(.+?)(/\d+\.\d+(\.\d+)?)?/(.*$)')

class Commit(object):
    def __init__(self, hashcode, message):
        self.hash = hashcode
        self.message = message

    def __repr__(self):
        return "Commit(%s): %s" % (self.hash, self.message)


def is_backport_branch(branch_name):
    result = BACKPORT_BRANCH_CHECK.match(branch_name)
    return result


def local_branch_name(branch_name):
    return branch_name if not branch_name.startswith("remotes/origin/") else branch_name[15:]

_all_branches_cache = None

def all_branches(use_cache=True):
    """
    Get all the git branches available in this git repository.
    It will also cache them, so operations such as adding branches,
    should call this function with use_cahe=False
    """
    global _all_branches_cache

    if _all_branches_cache and use_cache:
        return _all_branches_cache

    _all_branches_cache = set(map(local_branch_name,
                           filter(lambda line: not ' ' in line,
                                  map(lambda line: line.strip(),
                                  subprocess.check_output(["git", "branch", "-a"]).split("\n")))))

    return _all_branches_cache


def find_branch_by_issue_id(version, issue_id):
    branches = None

    version_substring = '/%s/' % version
    issue_substring = '/%s-' % issue_id

    if version == "master" or version == "develop":
        print("gonna find develop")
        branches = filter(lambda branch: not is_backport_branch(branch) and issue_substring in branch,
                          all_branches())
    else:        
        print("gonna find backport")
        branches = filter(lambda line: version_substring in line and issue_substring in line,
                          all_branches())

    if len(branches) > 1:
        raise Exception("Multiple branches were found for version %s, and issue %s: %s" % 
                        (version, issue_id, branches))

    if len(branches) == 0:
        raise Exception("No branch was found for version %s, and issue %s." % 
                        (version, issue_id))

    return branches[0]


def get_branch_name_for_different_version(existing_branch_name, version):
    m = BRANCH_NAME_PARSER.match(existing_branch_name)

    if not m:
        raise Exception("Unable to parse branch name: %s" % existing_branch_name)

    if version == "master" or version == "develop":
        return "%s/%s" % (m.group(2), m.group(5)) 

    return "%s/%s/%s" % (m.group(2), version, m.group(5)) 


def get_base_branch(version):
    if version == "master" or version == "develop":
        return version

    if ('maint/' + version) in all_branches():
        return 'maint/' + version

    if ('release/' + version) in all_branches():
        return 'release/' + version

    raise Exception("Unable to find a maint/%s nor a release/%s branch." % (version, version))

def get_commits_for_branch(branch_name, issue_id = None):
    all_commits = map(lambda arr: Commit(arr[0], arr[1]),
                      map(lambda line: line.strip().split(' ', 1),
                          subprocess.check_output(["git", "log", '--pretty=format:%H %s', branch_name]).split("\n")))

    if not issue_id:
        return all_commits

    issue_marker = re.compile('%s\W' % issue_id)  # FIXME: not so great
    merge_test = re.compile('^Merge')

    return filter(lambda commit: issue_marker.match(commit.message) and not merge_test.match(commit.message),
                  all_commits)

from_branch = find_branch_by_issue_id(from_version, issue_id)
to_branch = get_branch_name_for_different_version(from_branch, to_version)

if to_branch in all_branches():
    raise Exception("Branch %s already exists." % to_branch)

commits_to_apply = list(reversed(get_commits_for_branch(from_branch, issue_id)))

print("Going to try:")
print("====================================================================================")
print("git checkout %s" % get_base_branch(to_version))
print("git checkout -b %s" % to_branch)
for commit in commits_to_apply:
    print("# %s" % commit.message)
    print("git cherry-pick %s" % commit.hash)
print("git push --set-upstream origin %s" % to_branch)
print("====================================================================================")

raw_input("Press Enter to continue...")

print("git checkout %s" % get_base_branch(to_version))
subprocess.check_call(["git", "checkout", get_base_branch(to_version)])
print("git checkout -b %s" % to_branch)
subprocess.check_call(["git", "checkout", "-b", to_branch])

for commit in commits_to_apply:
    print("# %s" % commit.message)
    print("git cherry-pick %s" % commit.hash)
    subprocess.check_call(["git", "cherry-pick", commit.hash])

subprocess.check_call(["git", "push", "--set-upstream", "origin", to_branch])

print("DONE")

#from_branch = get_existing_branch_name(from_version, issue_id)

#if not from_branch:
#    raise Exception("Unable to find a feature branch for %s in version %s." % (issue_id, from_version))

#commits = find_commits_for_issue(from_branch, issue_id)

#if len(commits) == 0:
#    raise Exception("Unable to find the %s in the %s version branch.")

