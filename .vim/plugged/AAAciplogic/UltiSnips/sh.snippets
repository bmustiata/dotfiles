snippet c "Add a comment"
# ${VISUAL}${0:}
endsnippet

#
# snippet: cd
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a documentation comment
#
snippet cd "Add a documentation comment" wm
#
# ${1:name}
# ${0:description}
#
endsnippet

snippet cs "Add a comment mega section"
#############################################################################
# ${VISUAL}${0:}
#############################################################################
endsnippet

#
# snippet: ecs
# w (word boundary),
# m (trim spaces on the right of the script)
# Add an echo comment mega section
#
snippet ecs "Add an echo comment mega section" wm
echo "#############################################################################"
echo "# ${VISUAL}${0:}"
echo "#############################################################################"
endsnippet

snippet if "Create a bash if statement" wm
if [[ ${1:condition} ]]; then
	${VISUAL}${0:}
fi # [[ $1 ]]
endsnippet

#
# snippet: while
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a while statement
#
snippet while "Add a while statement" wm
while [[ ${1:condition} ]]; do
	${VISUAL}${0:}
done # [[ $1 ]]
endsnippet

#
# snippet: ifi
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a base inline if statement
#
snippet ifi "Create a base inline if statement" wm
if [${1:[} ${2:condition} ${1/.+/]/}]; then ${VISUAL}${0:}; fi
endsnippet

snippet iffile "Create a bash if statement that checks for a file if it exists"
if [ ${1:! }-f ${2:path} ]; then
	${VISUAL}${0:}
fi # [ $1-f $2 ]
endsnippet

snippet ifdir "Create a bash if statement that checks for a directory if it exists"
if [ ${1:! }-d ${2:path} ]; then
	${VISUAL}${0:}
fi # [ $1-d $2 ]
endsnippet

snippet ife "Create a bash if/else statement"
if [[ ${1:condition} ]]; then
	${VISUAL}${0:}
else # not [[ $1 ]]

fi   # else [[ $1 ]]
endsnippet

#
# snippet: elif
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an elif statement
#
snippet elif "Create an elif statement" wm
elif [[ ${1:condition} ]]; then
	${VISUAL}${0:}
endsnippet


#
# snippet: case
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a case statement
#
snippet switch "Add a case statement" wm
case "${1:$VARIABLE}" in
	"${2:value}")
		${VISUAL}${0:}
	;;
	*)
		# default
	;;
esac
endsnippet

#
# snippet: cb
# w (word boundary),
# m (trim spaces on the right of the script)
# Case branch
#
snippet case "Case branch" wm
"${1:VALUE}")
	${VISUAL}${0:}
;;
endsnippet

snippet fun "Create a function"
${1:name}() {
	${VISUAL}${0:}
}
endsnippet

snippet for "Create a for loop"
for ${1:f} in ${2:\`ls\`}; do
	${VISUAL}${0:}
done
endsnippet

#
# snippet: foria
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a for loop assigned over an array
#
snippet foria "Create a for loop assigned over an array" wm
for ${1:e} in "${${2:array}[@]}"; do
	${VISUAL}${0:}
done
endsnippet

snippet bash "Adds a bash #!/usr/bin/env declaration."
#!/usr/bin/env bash${0:}
endsnippet

snippet sh "Adds a sh #!/bin/sh declaration."
#!/bin/sh${0:}
endsnippet


snippet mlsvar "Add a multiline string value"
read -r -d '' ${1:VALUE} << ${2:EOM}
${VISUAL}${0:}
$2
endsnippet

#
# snippet: mls
# w (word boundary),
# m (trim spaces on the right of the script)
# Displays a multiline string on the screen using cat.
#
snippet mls "Displays a multiline string on the screen using cat." wm
${2:cat}${1/.+/ /}${1/.+/> /}${1:FILE_NAME} << ${3:EOM}
${VISUAL}${0:}
$3
endsnippet

# The extra readlink is there to get the absolute path
# even if there are linked folders.
snippet curdir "Get the current directory in a bash script as an absolute path" i
$(readlink -f "$(dirname "\$0")${VISUAL}")
endsnippet

#
# snippet: projectdir
# w (word boundary),
# m (trim spaces on the right of the script)
# Get the project dir into a variable
#
snippet projectdir "Get the project dir into a variable" wm
${1:PROJECT_FOLDER}=$(readlink -f "$(dirname "\$0")${VISUAL/^$/\/../}")
endsnippet

snippet path "Add an item to the PATH"
export PATH="${VISUAL}${1:}:$PATH"${0:}
endsnippet

#
# snippet: s
# w (word boundary),
# m (trim spaces on the right of the script)
# Wrap the text in a string.
#
snippet s "Wrap the text in a string." wm
"${1:${VISUAL/^$/text/}}"${0:}
endsnippet

#
# snippet: resolve
# w (word boundary),
# m (trim spaces on the right of the script)
# Resolve the path to its absolute value
#
snippet resolve "Resolve the path to its absolute value" wm
$(readlink -f ${1:${VISUAL/^$/file/}})
endsnippet

#
# snippet: dir
# w (word boundary),
# m (trim spaces on the right of the script)
# Get the directory path for the given path
#
snippet dir "Get the directory path for the given path" wm
$(dirname ${VISUAL/^$/filepath/})
endsnippet

#
# snippet: var
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a variable around the visible selection
#
snippet var "Create a variable around the visible selection" wm
${2:export }${1:NAME}="${0:${VISUAL}}"
endsnippet

#
# snippet: split
# w (word boundary),
# m (trim spaces on the right of the script)
# Split a string into an array
#
snippet split "Split a string into an array" wm
IFS='${1:,}' read -r -a ${2:outputarray} <<< "${3:$inputstr}"
endsnippet

#
# snippet: contains
# w (word boundary),
# m (trim spaces on the right of the script)
# Check if a string variable contains another text value
#
snippet contains "Check if a string variable contains another text value" wm
${1:\$VAR} = *"${2:contained text}"*
endsnippet

#
# snippet: e
# w (word boundary),
# m (trim spaces on the right of the script)
# echo
#
snippet e "echo" wm
echo "${VISUAL}${1:}"
endsnippet

#
# snippet: zip
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a zip archive
#
snippet zip "Create a zip archive" wm
zip -r ${1:filename.zip} ${2:files/}
endsnippet

#
# snippet: flag
# w (word boundary),
# m (trim spaces on the right of the script)
# Add flag parsing
#
snippet flag "Add flag parsing" wm
while test $# -gt 0; do
	case "\$1" in
		-h|--help)
			echo "Help"
			;;
		*)
			break
			;;
	esac
done
endsnippet

#
# snippet: cwd
# w (word boundary),
# m (trim spaces on the right of the script)
# Current working directory in bash
#
snippet curdirpwd "Current working directory in bash" wm
$(cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd -P)
endsnippet


#
# snippet: lower
# w (word boundary),
# m (trim spaces on the right of the script)
# String to the lowercase
#
snippet lower "String to the lowercase" wm
tr '[:upper:]' '[:lower:]'
endsnippet

#
# snippet: trap
# w (word boundary),
# m (trim spaces on the right of the script)
# Add some cleanup code
#
snippet trap "Add some cleanup code" wm
${1:cleanup}() {
	${VISUAL}${0:}
}

trap $1 ${2:EXIT}
endsnippet

#
# snippet: sed
# w (word boundary),
# m (trim spaces on the right of the script)
# sed replace in-place
#
snippet sed "sed replace in-place (regex e)" wm
sed -ie 's${1:/}${2:SEARCH}$1${3:REPLACEMENT}$1g' ${4:filename}
endsnippet

#
# snippet: sedstar
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a *? to the regexp
#
snippet sedstar "Add a *? to the regexp" wm
${VISUAL}\{0,\}
endsnippet

#
# snippet: sedplus
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a +? to the regexp
#
snippet sedplus "Add a +? to the regexp" wm
${VISUAL}\{1,\}
endsnippet

#
# snippet: sedgroup
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a group to the regexp
#
snippet sedgroup "Add a group to the regexp" wm
\(${VISUAL}\)
endsnippet

#
# snippet: sedw
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a \\w to the regexp
#
snippet sedw "Add a \w to the regexp" wm
[[:space:]]
endsnippet

#
# snippet: extremove
# w (word boundary),
# m (trim spaces on the right of the script)
# Remove the extension
#
snippet extremove "Remove the extension" wm
${${1:VARNAME}%%.*}
endsnippet

