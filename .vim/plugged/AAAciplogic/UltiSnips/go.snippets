#
# snippet: struct
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a struct
#
snippet struct "Create a struct" wm
type ${1:StructName} struct {
	${0:a int64
	b string}
}
endsnippet

#
# snippet: func
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a function
#
snippet fun "Create a function" wm
func ${1/.+/(/}${1:this ThisType}${1/.+/) /}${2:fnname}(${3:value string}) ${5/.+/(/}${4:string}${5/.+/, /}${5:error}${5/.+/) /}{
	${0:return "abc", 0}
}
endsnippet

#
# snippet: func
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a function
#
snippet func "Create a function" wm
func ${1/.+/(/}${1:this ThisType}${1/.+/) /}${2:fnname}(${3:value string}) ${5/.+/(/}${4:string}${5/.+/, /}${5:error}${5/.+/) /}{
	${0:return "abc", 0}
}
endsnippet

#
# snippet: cs
# w (word boundary),
# m (trim spaces on the right of the script)
# Comment section
#
snippet cs "Comment section" wm
/*
${VISUAL}${0:}
*/
endsnippet

#
# snippet: c
# w (word boundary),
# m (trim spaces on the right of the script)
# comment
#
snippet c "comment" wm
// ${VISUAL}${0:}
endsnippet

#
# snippet: open
# w (word boundary),
# m (trim spaces on the right of the script)
# Open a file
#
snippet open "Open a file" wm
${1:file}, ${2:err} := os.Open(${3:"test.txt"})

if $2 != nil {
	log.Fatal($2)
}

defer $1.Close()
endsnippet

#
# snippet: append
# w (word boundary),
# m (trim spaces on the right of the script)
# Open a file for append
#
snippet append "Open a file for append" wm
f, err := os.OpenFile(${1:"text.log"},
	os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

if err != nil {
	log.Fatal(err)
}

defer f.Close()

if _, err := f.WriteString("text to append\n"); err != nil {
	log.Fatal(err)
}

endsnippet

#
# snippet: eachline
# w (word boundary),
# m (trim spaces on the right of the script)
# For each line
#
snippet eachline "For each line" wm
${1:scanner} := bufio.NewScanner(${2:file})
for $1.Scan() {
	fmt.Println($1.Text())
}

if ${3:err} := $1.Err(); $3 != nil {
	${0:log.Fatal($3)}
}
endsnippet

#
# snippet: ed
# w (word boundary),
# m (trim spaces on the right of the script)
# Regular call error parsing with death
#
snippet ed "Regular call error parsing with death" wm
${1:vars}${1/.+/, /}err := ${2:${VISUAL}}

if err != nil {
	log.Fatal(err)
}
endsnippet

#
# snippet: map
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a map
#
snippet map "Create a map" wm
map[${1:key}]${2:value}
endsnippet
