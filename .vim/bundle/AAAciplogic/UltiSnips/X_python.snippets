snippet super "Add a super call"
super(${1:SuperClass}, self).__init__(${2:parameters})
endsnippet

snippet from "Adds a from .. import"
from ${1:name} import ${2:$1}
endsnippet

snippet P "Create a behave parameter" i
(?P<${1:name}>.*?)
endsnippet

snippet self "Create an assignment"
self._${1:name} = $1${0:}
endsnippet

#
# snippet: def
# w (word boundary),
# m (trim spaces on the right of the script)
# Define a method or function
#
snippet def "Define a method or function" wm
def ${1:name}(${2:self})${3/.+/ -> /}${3:None}:${4/.+/
	"""
	/}${4:documentation}${4/.+/
	"""/}
	${0:pass}
endsnippet

snippet /^(\s*)sdef$/ "Define a static method" r
`!p snip.rv += match.group(1)`@classmethod
`!p snip.rv += match.group(1)`def ${1:name}(${2:self}):
`!p snip.rv += match.group(1)`${3/.+/    """ /}${3:documentation}${3/.+/ """\n/}`!p snip.rv += match.group(1)`    ${VISUAL}${0:}
endsnippet

snippet c "Add a comment"
# ${VISUAL}${0:}
endsnippet

#
# snippet: cs
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a comment section
#
snippet cs "Add a comment section" wm
# ####################################################################
# ${VISUAL}${0:}
# ####################################################################
endsnippet

snippet """ "Add a pydoc comment"
"""
${VISUAL}${0:}
"""
endsnippet

snippet try "Add a try/except statement"
try:
	${VISUAL}${0:}
except Exception as ${1:e}:
	${2:pass}
endsnippet

snippet trye "Add a try/except/finally statement"
try:
	${VISUAL}${0:}
except Exception as ${1:e}:
	${2:pass}
finally:
	${3:pass}
endsnippet

snippet tryf "Add a try/finally statement"
try:
	${VISUAL}${0:}
finally:
	${1:pass}
endsnippet

#
# snippet: while
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a whle block
#
snippet while "Add a whle block" wm
while ${1:condition}:
	${VISUAL}${0:}
endsnippet

snippet trygermanium "Add a germanium try/except/finally block"
try:
	${VISUAL}${0:}
except Exception as e:
	print("test failed: " + str(e))
	germanium.take_screenshot("WpTestLogin")
finally:
	germanium.quit()
endsnippet

snippet python "Add python as a shell script"
#!/usr/bin/env python
endsnippet

snippet step "Add a behave step"
@step("${1:step definition}")
${2/.+/@iframe("/}${2:default}${2/.+/")/}
def ${3:step_impl}(context):
	${0:pass}
endsnippet

snippet print "Add a print"
print(${0:})
endsnippet

#
# snippet: setup
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a setup section.
#
snippet setup "Create a setup section." wm
from setuptools import setup, find_packages

with open('README.rst') as readme_file:
	readme = readme_file.read()

install_requires = []
with open('requirements.txt', mode='r') as requirements_file:
	for line in requirements_file.readlines():
		if line and not line.startswith('#'):
			install_requires.append(line)

packages = find_packages()

setup(
	name='${1:germanium}',
	version='${2:1.10.5}',
	description='${3:The germanium project: Selenium WebDriver testing API that doesn\'t disappoint.}',
	long_description=readme,
	author='${4:Bogdan Mustiata}',
	author_email='${5:bogdan.mustiata@gmail.com}',
	license='${6:BSD}',
	install_requires=install_requires,
	packages=packages${8/.+/,
	package_data={
		'/}${8:$1}${8/.+/': ['*.js'],
	}
/})
endsnippet

#
# snippet: cm
# w (word boundary),
# m (trim spaces on the right of the script)
# Method comment
#
snippet cm "Method comment" wm
"""
${VISUAL}${0:}
"""
endsnippet

#
# snippet: for
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a for loop.
#
snippet for "Create a for loop." wm
for ${1:item} in ${2:$1s}:
	${0:${VISUAL}}
endsnippet

#
# snippet: decorator
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a decorator
#
snippet decorator "Create a decorator" wm
def ${1:decorator_name}(f: Callable[..., T]) -> Callable[..., T]:
	@functools.wraps(f)
	def wrapper(*args, **kw) -> T:
		${0:}
		return f(*args, **kw)

	return wrapper
endsnippet

#
# snippet: decoratorp
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a decorator with parameters
#
snippet decoratorp "Create a decorator with parameters" wm
def ${1:decorator_name}(${2:p}) -> Callable[..., Callable[..., T]]:
	def wrapper_builder(f: Callable[..., T]) -> Callable[..., T]:
		@functools.wraps(f)
		def wrapper(*args, **kw) -> T:
			${0:}
			return f(*args, **kw)

		return wrapper

	return wrapper_builder
endsnippet

#
# snippet: taga
# w (word boundary),
# m (trim spaces on the right of the script)
# asciidoctor tag for code
#
snippet taga "asciidoctor tag for code" wm
#tag::${1:name}[]
${VISUAL}${0:}
#end::$1[]
endsnippet

#
# snippet: open
# w (word boundary),
# m (trim spaces on the right of the script)
# with open...
#
snippet open "with open..." wm
with open(${1:'filename'}${2/.+/, '/}${2:r}${2/.+/'/}${3/.+/, encoding='/}${3:utf-8}${3/.+/'/}) as ${4:f}:
	${5:content} = $4.read()
endsnippet

#
# snippet: main
# w (word boundary),
# m (trim spaces on the right of the script)
# __main__ if check
#
snippet main "__main__ if check" wm
if __name__ == '__main__':
	${VISUAL}${0:}
endsnippet

#
# snippet: launch
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a launcher script
#
snippet launch "Create a launcher script" wm
from ${1:thriftgen.mainapp} import main


def launch():
	main()


if __name__ == '__main__':
	main()
endsnippet

#
# snippet: entry
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an entry point console script
#
snippet entry "Create an entry point console script" wm
entry_points = {
	"console_scripts": [
		"${1:thriftgen} = ${2:thriftgen}.launcher:${3:launch}"
	]
},
endsnippet

#
# snippet: data
# w (word boundary),
# m (trim spaces on the right of the script)
# Add some package data in the setup.py
#
snippet data "Add some package data in the setup.py" wm
package_data={
	'': ['*.txt', '*.rst']
}
endsnippet

#
# snippet: curdir
# w (word boundary),
# m (trim spaces on the right of the script)
# The current dir
#
snippet curdir "The current project dir" wm
PROJECT_DIR = os.path.realpath(os.path.join(os.path.dirname(__file__), '..'))
endsnippet

#
# snippet: class
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a new class
#
snippet class "Create a new class" wm
`!p
def notype(x: str) -> str:
	return re.sub(r"\s*\:.*$", "", x)

def noval(x: str) -> str:
	return re.sub(r"\s*\=.*$", "", x)
`
class ${1:ThriftyService}${2/.+/(/}${2:object}${2/.+/)/}:
	"""
	${3:$1 documentation.}
	"""
	def __init__(self${4:, name: str}) -> None:
`!p
#
# generate self assignments
#
for arg in map(lambda it: it.strip(), re.split("\s*,\s*", t[4])):
	if arg != "":
		snip.rv += f'        self.{notype(arg)} = {notype(arg)}\n'
`        ${0:pass}

endsnippet

#
# snippet: opt
# w (word boundary),
# m (trim spaces on the right of the script)
# Optional var
#
snippet opt "Optional var" wm
Optional[${1:${VISUAL}}]${2/.+/=/}${2:None}${0:}
endsnippet

#
# snippet: optn
# w (word boundary),
# m (trim spaces on the right of the script)
# Optional None var
#
snippet optn "Optional None var" wm
Optional[${VISUAL}${1:}]=None${0:}
endsnippet

#
# snippet: awslambda
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a new AWS lambda
#
snippet awslambda "Create a new AWS lambda" wm
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import json
import boto3
from botocore.vendored import requests


def lambda_handler(event, context):
	try:
		bucket = event['ResourceProperties']['BucketName']

		if event['RequestType'] == 'Delete':
			s3 = boto3.resource('s3')
			bucket = s3.Bucket(bucket)
			for obj in bucket.objects.filter():
				s3.Object(bucket.name, obj.key).delete()

		sendResponseCfn(event, context, "SUCCESS")
	except Exception as e:
		print(e)
		sendResponseCfn(event, context, "FAILED")


def sendResponseCfn(event, context, responseStatus):
	response_body = {'Status': responseStatus,
					 'Reason': 'Log stream name: ' + context.log_stream_name,
					 'PhysicalResourceId': context.log_stream_name,
					 'StackId': event['StackId'],
					 'RequestId': event['RequestId'],
					 'LogicalResourceId': event['LogicalResourceId'],
					 'Data': json.loads("{}")}

	requests.put(event['ResponseURL'], data=json.dumps(response_body))

endsnippet

#
# snippet: ui
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an UI resource
#
snippet ui "Create an UI resource" wm
from PySide2.QtWidgets import $2

from germanium_build_monitor.ui.generated.Ui_$1 import Ui_$1


class ${1:MainWindow}(${2:QMainWindow}, Ui_$1):
	def __init__(self) -> None:
		super($1, self).__init__()

		self.setupUi(self)
		${0:}
endsnippet

#
# snippet: uif
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an UI resource
#
snippet uif "Create an UI frame resource" wm
from PySide2.QtWidgets import QWidget

from germanium_build_monitor.ui.generated.Ui_$1 import Ui_Form


class ${1:CoolFrame}(QWidget, Ui_Form):
	def __init__(self) -> None:
		super().__init__()

		self.setupUi(self)
		${0:}
endsnippet

#
# snippet: uid
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an UI resource
#
snippet uid "Create an UI dialog resource" wm
from PySide2.QtWidgets import QDialog

from germanium_build_monitor.ui.generated.Ui_$1 import Ui_Dialog


class ${1:CoolFrame}(QDialog, Ui_Dialog):
	def __init__(self, *args, **kw) -> None:
		super().__init__(*args, **kw)

		self.setupUi(self)
		${0:}
endsnippet

#
# snippet: proxy
# w (word boundary),
# m (trim spaces on the right of the script)
# create a proxy
#
snippet proxy "create a proxy" wm
@action
def ${1:name}(self, *argv, **kw):
	result = super().$1(*argv, **kw)
	self._mopyx_model._mopyx_register_refresh(self._mopyx_property_name)
	return result
endsnippet

#
# snippet: argparse
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an argument parser
#
snippet argparse "Create an argument parser" wm
parser = argparse.ArgumentParser(description='${1:Process some integers.}')

parser.add_argument('integers', metavar='N', type=int, nargs='+',
                    help='an integer for the accumulator')
parser.add_argument('--sum', dest='accumulate', action='store_const',
                    const=sum, default=max,
                    help='sum the integers (default: find the max)')

args = parser.parse_args()
endsnippet

#
# snippet: if
# w (word boundary),
# m (trim spaces on the right of the script)
# Add an if statement
#
snippet if "Add an if statement" wm
if ${1:expression}:
	${VISUAL}${0:}
endsnippet

#
# snippet: log
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a logger
#
snippet logger "Create a logger" wm
import logging

LOG = logging.getLogger(__name__)
endsnippet

#
# snippet: repr
# w (word boundary),
# m (trim spaces on the right of the script)
# create a __repr__ for the object
#
snippet repr "create a __repr__ for the object" wm
def __repr__(self) -> str:
	${0:}
endsnippet

#
# snippet: enum
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an enum
#
snippet enum "Create an enum" wm
class ${1:EnumName}(Enum):
	${2:NEW} = '$2'
endsnippet
