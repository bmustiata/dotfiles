snippet super "Add a super call"
super(${1:SuperClass}, self).__init__(${2:parameters})
endsnippet

snippet from "Adds a from .. import"
from ${1:name} import ${2:$1}
endsnippet

snippet P "Create a behave parameter" i
(?P<${1:name}>.*?)
endsnippet

snippet self "Create an assignment"
self._${1:name} = $1${0:}
endsnippet

snippet /^(\s*)def$/ "Define a method or function" r
`!p snip.rv += match.group(1)`def ${1:name}(${2:self}):
`!p snip.rv += match.group(1)`${3/.+/    """ /}${3:documentation}${3/.+/ """\n/}`!p snip.rv += match.group(1)`    ${VISUAL}${0:}
endsnippet

snippet /^(\s*)sdef$/ "Define a static method" r
`!p snip.rv += match.group(1)`@classmethod
`!p snip.rv += match.group(1)`def ${1:name}(${2:self}):
`!p snip.rv += match.group(1)`${3/.+/    """ /}${3:documentation}${3/.+/ """\n/}`!p snip.rv += match.group(1)`    ${VISUAL}${0:}
endsnippet

snippet class "Create a new class."
class ${1:ClassName}(${2:object}):
	"""
	${3:Class Documentation}
	"""
	def __init__(self${4:}) -> None:
		${0:pass}
endsnippet

snippet c "Add a comment"
${VISUAL/^(\s*)(.*?)$/$1/}#  ${VISUAL/^(\s*)(.*?)$/$2/}${0:}
endsnippet

snippet """ "Add a pydoc comment"
"""
${VISUAL}${0:}
"""
endsnippet

snippet try "Add a try/except statement"
try:
	${VISUAL}${0:}
except Exception as ${1:e}:
	${2:pass}
endsnippet

snippet trye "Add a try/except/finally statement"
try:
	${VISUAL}${0:}
except Exception as ${1:e}:
	${2:pass}
finally:
	${3:pass}
endsnippet

snippet tryf "Add a try/finally statement"
try:
	${VISUAL}${0:}
finally:
	${1:pass}
endsnippet

#
# snippet: while
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a whle block
#
snippet while "Add a whle block" wm
while ${1:condition}:
	${VISUAL}${0:}
endsnippet

snippet trygermanium "Add a germanium try/except/finally block"
try:
	${VISUAL}${0:}
except Exception as e:
	print("test failed: " + str(e))
	germanium.take_screenshot("WpTestLogin")
finally:
	germanium.quit()
endsnippet

snippet python "Add python as a shell script"
#!/usr/bin/env python
endsnippet

snippet step "Add a behave step"
@step("${1:step definition}")
${2/.+/@iframe("/}${2:default}${2/.+/")/}
def ${3:step_impl}(context):
	${0:pass}
endsnippet

snippet print "Add a print"
print(${0:})
endsnippet

#
# snippet: cs
# w (word boundary),
# m (trim spaces on the right of the script)
# Add a comment section.
#
snippet cs "Add a comment section." wm
# ====================================================
# ${VISUAL}${0:}
# ====================================================
endsnippet

#
# snippet: setup
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a setup section.
#
snippet setup "Create a setup section." wm
from setuptools import setup, find_packages

with open('README.rst') as readme_file:
	readme = readme_file.read()

install_requires = []
with open('requirements.txt', mode='r') as requirements_file:
	for line in requirements_file.readlines():
		if line and not line.startswith('#'):
			install_requires.append(line)

packages = find_packages()

setup(
	name='${1:germanium}',
	version='${2:1.10.5}',
	description='${3:The germanium project: Selenium WebDriver testing API that doesn\'t disappoint.}',
	long_description=readme,
	author='${4:Bogdan Mustiata}',
	author_email='${5:bogdan.mustiata@gmail.com}',
	license='${6:BSD}',
	install_requires=install_requires,
	packages=packages${8/.+/,
	package_data={
		'/}${8:$1}${8/.+/': ['*.js'],
	}
/})
endsnippet

#
# snippet: cm
# w (word boundary),
# m (trim spaces on the right of the script)
# Method comment
#
snippet cm "Method comment" wm
"""
${VISUAL}${0:}
"""
endsnippet

#
# snippet: for
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a for loop.
#
snippet for "Create a for loop." wm
for ${1:item} in ${2:$1s}:
	${0:${VISUAL}}
endsnippet

#
# snippet: decorator
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a decorator
#
snippet decorator "Create a decorator" wm
def ${1:decorator_name}(f: Callable[..., T]) -> Callable[..., T]:
	@functools.wraps(f)
	def wrapper(*args, **kw) -> T:
		${0:}
		return f(*args, **params)

	return wrapper
endsnippet

#
# snippet: decoratorp
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a decorator with parameters
#
snippet decoratorp "Create a decorator with parameters" wm
def ${1:decorator_name}(${2:p}) -> Callable[..., Callable[..., T]]:
	def wrapper_builder(f: Callable[..., T]) -> Callable[..., T]:
		@functools.wraps(f)
		def wrapper(*args, **kw) -> T:
			${0:}
			return f(*args, **kw)

		return wrapper

	return wrapper_builder
endsnippet

#
# snippet: taga
# w (word boundary),
# m (trim spaces on the right of the script)
# asciidoctor tag for code
#
snippet taga "asciidoctor tag for code" wm
#tag::${1:name}[]
${VISUAL}${0:}
#end::$1[]
endsnippet

#
# snippet: open
# w (word boundary),
# m (trim spaces on the right of the script)
# with open...
#
snippet open "with open..." wm
with open(${1:'filename'}) as ${2:f}:
	${3:content = $2.read()}
endsnippet

#
# snippet: main
# w (word boundary),
# m (trim spaces on the right of the script)
# __main__ if check
#
snippet main "__main__ if check" wm
if __name__ == '__main__':
	${VISUAL}${0:}
endsnippet

#
# snippet: launch
# w (word boundary),
# m (trim spaces on the right of the script)
# Create a launcher script
#
snippet launch "Create a launcher script" wm
from ${1:thriftgen.mainapp} import main


def launch():
	main()


if __name__ == '__main__':
	main()
endsnippet

#
# snippet: entry
# w (word boundary),
# m (trim spaces on the right of the script)
# Create an entry point console script
#
snippet entry "Create an entry point console script" wm
entry_points = {
	"console_scripts": [
		"${1:thriftgen} = ${2:thriftgen}.launcher:${3:launch}"
	]
},
endsnippet

#
# snippet: data
# w (word boundary),
# m (trim spaces on the right of the script)
# Add some package data in the setup.py
#
snippet data "Add some package data in the setup.py" wm
package_data={
	'': ['*.txt', '*.rst']
}
endsnippet

#
# snippet: curdir
# w (word boundary),
# m (trim spaces on the right of the script)
# The current dir
#
snippet curdir "The current project dir" wm
PROJECT_DIR = os.path.realpath(os.path.join(os.path.dirname(__file__), '..'))
endsnippet
